/*-
 * Copyright (c) 2015 Alexander Nasonov.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * If you're wonderning about coding style, it's documented in
 * /usr/share/misc/style which can be found online at this address
 * http://cvsweb.netbsd.org/bsdweb.cgi/src/share/misc/style
 */

#include <assert.h>
#include <errno.h>
#include <limits.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "rgph_defs.h"
#include "rgph_hash.h"
#include "rgph_graph.h"

/*
 * The algorithm below is based on paper
 * Cache-Oblivious Peeling of Random Hypergraphs by Djamal Belazzougui,
 * Paolo Boldi, Giuseppe Ottaviano, Rossano Venturini, and Sebastiano
 * Vigna.
 * http://zola.di.unipi.it/rossano/wp-content/papercite-data/pdf/dcc14.pdf
 */
namespace {

template<class T, int R>
struct edge {
	T verts[R]; // v0, v1 (and v2, if R==3).
	T index; // XXX
};

/*
 * Data type for a valid oriented edge (v0, v1, v2), v1 < v2.
 * The first vertex v0 is implicit and is determined by an index
 * of the corresponding element in the oedges array.
 * If the degree of v0 is greater than 1, other members don't make
 * sense because they're a result of XORing multiple random values.
 */
template<class T, int R>
struct oedge {
	T overts[R-1]; // v1 (and v2, if R==3).
	T degree;      // Degree of v0.
	T edge;
};

template<class T>
struct hash {
	mutable T hashes[3];
	T seed;
	hash(T s)
		: seed(s)
	{}

	const T *operator()(const void *key, size_t keylen) const {
		rgph_u32x3_jenkins2_u8a((const uint8_t *)key, keylen, seed, hashes);
		return hashes;
	}
};

template<class T>
inline void
add_remove_oedge(oedge<T,2> *oedges, int delta, T e, T v0, T v1)
{

	oedges[v0].overts[0] ^= v1;
	oedges[v0].degree += delta;
	oedges[v0].edge ^= e;
}

template<class T>
inline void
remove_edge(oedge<T,2> *oedges, T e, T v0, T v1)
{

	return add_remove_oedge(oedges, -1, e, v0, v1);
}

template<class T>
inline void
add_remove_oedge(oedge<T,3> *oedges, int delta, T e, T v0, T v1, T v2)
{

	oedges[v0].overts[v1 < v2 ? 0 : 1] ^= v1;
	oedges[v0].overts[v1 < v2 ? 1 : 0] ^= v2;
	oedges[v0].degree += delta;
	oedges[v0].edge ^= e;
}

template<class T>
inline void
remove_oedge(oedge<T,2> *oedges, T e, T v0, T v1)
{

	return add_remove_oedge(oedges, -1, e, v0, v1);
}

template<class T>
inline void
remove_oedge(oedge<T,3> *oedges, T e, T v0, T v1, T v2)
{

	return add_remove_oedge(oedges, -1, e, v0, v1, v2);
}

template<class T>
inline void
add_edge(oedge<T,2> *oedges, T e, const T *verts)
{

	add_remove_oedge(oedges, 1, e, verts[0], verts[1]);
	add_remove_oedge(oedges, 1, e, verts[1], verts[0]);
}

template<class T>
inline void
add_edge(oedge<T,3> *oedges, T e, const T *verts)
{

	add_remove_oedge(oedges, 1, e, verts[0], verts[1], verts[2]);
	add_remove_oedge(oedges, 1, e, verts[1], verts[0], verts[2]);
	add_remove_oedge(oedges, 1, e, verts[2], verts[0], verts[1]);
}

template<class T>
inline size_t
remove_vertex(oedge<T,2> *oedges, T v0, T *order, size_t end)
{

	if (oedges[v0].degree == 1) {
		const T e = oedges[v0].edge;
		const T v1 = oedges[v0].overts[0];
		oedges[v0].degree = 0;
		remove_oedge(oedges, e, v1, v0);
		order[--end] = e;
	}

	return end;
}

template<class T>
inline size_t
remove_vertex(oedge<T,3> *oedges, T v0, T *order, size_t end)
{

	if (oedges[v0].degree == 1) {
		const T e = oedges[v0].edge;
		const T v1 = oedges[v0].overts[0];
		const T v2 = oedges[v0].overts[1];
		oedges[v0].degree = 0;
		remove_oedge(oedges, e, v1, v0, v2);
		remove_oedge(oedges, e, v2, v0, v1);
		order[--end] = e;
	}

	return end;
}

template<class Iter, class Hash, class T, int R>
void
build_graph(Iter keys, size_t nkeys, Hash hash, size_t nverts,
    edge<T,R> *edges, oedge<T,R> *oedges)
{
	// Partition size of an R-partite R-graph.
	const T partsz = nverts / R;
	assert(partsz > 1 && (nverts % R) == 0);

	for (T i = 0; i < nkeys; ++i, ++keys) {
		const T *verts = hash(keys->key, keys->keylen);
		for (size_t r = 0; r < R; ++r)
			edges[i].verts[r] = (verts[r] % partsz) + r * partsz;
		add_edge(oedges, i, edges[i].verts);
	}
}

template<class T, int R>
size_t
peel_graph(edge<T,R> *edges, size_t nkeys, oedge<T,R> *oedges, T *order)
{
	size_t end = nkeys;

	for (size_t i = 0; i < nkeys; ++i)
		end = remove_vertex(oedges, i, order, end);

	for (size_t i = nkeys; i > 0 && i > end; --i) {
		const edge<T,R> &e = edges[order[i-1]];
		for (size_t r = 0; r < R; ++r)
			end = remove_vertex(oedges, e.verts[r], order, end);
	}

	return end;
}

} // namespace

struct rgph_graph {
	size_t nkeys;
	size_t nverts;
	void *order;
	void *edges;
	void *oedges;
	unsigned int flags;
};

struct key_val_iter {
	key_val_iter(rgph_entry_iterator_t i, void *s)
		: iter(i)
		, state(s)
		, cur(i(s))
	{}

	void operator++() {
		cur = iter(state);
	}

	struct rgph_entry *operator->() {
		return cur;
	}

	rgph_entry_iterator_t iter;
	void *state;
	struct rgph_entry *cur;
};

enum {
	PUBLIC_FLAGS = 0x3ff,
	ZEROED = 0x40000000
};

extern "C"
void
rgph_free_graph(struct rgph_graph *g)
{

	free(g->oedges);
	free(g->edges);
	free(g->order);
	free(g);
}

extern "C"
struct rgph_graph *
rgph_alloc_graph(size_t nkeys, int flags)
{
	struct rgph_graph *g;
	size_t nverts, esz, osz;
	int save_errno;
	int r;

	if (flags & ~PUBLIC_FLAGS) {
		errno = EINVAL;
		return NULL;
	}

	r = (flags & RGPH_RANK_MASK) == RGPH_RANK2 ? 2 : 3;
	// XXX nverts overflow check.
	nverts = (r == 2) ? 2 * nkeys + (nkeys + 7) / 8
	                  : 1 * nkeys + (nkeys + 3) / 4;
	nverts = (nverts + (r - 1)) / r * r; // Round up.
	if (nverts < 24)
		nverts = 24;

	g = (struct rgph_graph *)calloc(sizeof(*g), 1);
	if (g == NULL)
		return NULL;

	g->nkeys = 0;
	g->nverts = 0;
	g->order = NULL;
	g->edges = NULL;
	g->oedges = NULL;
	g->flags = flags;

	// XXX other sizes of T
	esz = (r == 2) ? sizeof(edge<uint32_t,2>)
	               : sizeof(edge<uint32_t,3>);
	osz = (r == 2) ? sizeof(oedge<uint32_t,2>)
	               : sizeof(oedge<uint32_t,3>);

	g->order = calloc(esz, nkeys);
	if (g->order == NULL)
		goto err;

	g->edges = calloc(esz, nkeys);
	if (g->edges == NULL)
		goto err;

	g->oedges = calloc(osz, nverts);
	if (g->oedges == NULL)
		goto err;

	g->nkeys = nkeys;
	g->nverts = nverts;
	g->flags |= ZEROED; // calloc

	return g;
err:
	save_errno = errno;
	rgph_free_graph(g);
	errno = save_errno;
	return NULL;
}

extern "C"
int
rgph_build_graph(struct rgph_graph *g,
    rgph_entry_iterator_t keys, void *state, unsigned int seed)
{
	// XXX
	edge<uint32_t,3> *edges = (edge<uint32_t,3> *)g->edges;
	oedge<uint32_t,3> *oedges = (oedge<uint32_t,3> *)g->oedges;
	hash<uint32_t> hashes(seed);
	key_val_iter iter(keys, state);

	if (!(g->flags & ZEROED)) {
		// XXX
		memset(g->order, 0, 1);
		memset(g->edges, 0, 1);
		memset(g->oedges, 0, 1);
	}

	g->flags &= ~ZEROED;

	build_graph(iter, g->nkeys, hashes, g->nverts, edges, oedges);
	return peel_graph(edges, g->nkeys, oedges, (uint32_t *)g->order) != 0;
}
